## 1. Executive Summary ‚Äî ‚ÄúWhy ABIntel?‚Äù

ABIntel turns raw operational data into ready-to-act predictions and
plain-language narratives in under a minute. Teams typically launch their
first campaign or cost project within hours, compounding impact inside a
fiscal quarter.

### Challenge vs Outcome

| **Challenge**                      | **ABIntel‚Äôs Outcome (Proven in Production)**                                                                                                            |
| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Disconnected silo data, no ML team | ‚úÖ Plug-and-play microservices that ingest raw transactions, invoices, tickets, sensor feeds, or free-text and deliver actionable predictions in < 60s. |
| Slow time-to-value                 | ‚úÖ First campaign or cost project live in ‚â§ 2 hours; typical 6‚Äì14% EBIT uplift inside a fiscal quarter.                                                  |
| GPU expertise lacking              | ‚úÖ Automatic GPU acceleration with safe CPU fallback.                                                                                                    |
| Hand-offs between Data & Business  | ‚úÖ Every response includes English, Spanish, and Portuguese narratives so marketers, planners, and finance teams understand the ‚Äúso what‚Äù instantly.      |

---

## 1.1 Platform Architecture at a Glance

* üß© Kubernetes autoscaling up to **32√ó T4s** (or **H100s in Q4 2025**)
* üîê SOC 2 Type 2 audit in progress; **ISO 27001** certified DCs
* üöÄ Zero-downtime **canary releases**
* üè∑Ô∏è Semantic versioning via `/v1`

---

## 1.2 API Server

```
https://api-prod.abintel.app
```

---

## 1.3 Queue a Task ‚Üí `POST /api/v1/ai/{route}`

### Example

```http
POST /api/v1/ai/forecast_revenue
```

#### Headers

```http
Content-Type: application/json
X-Customer-Api-Id: 4d09ffe5-33d7-4a63-b4fd-fc1decf4fa8f
X-Secret: AfIqb2F9JNET_‚Ä¶HzHUa0w
```

#### Body

```json
{
  "region": "EU",
  "horizon": 12,
  "include_promotions": true
}
```

#### cURL

```bash
curl -sS -X POST \\
  https://api-prod.abintel.app/api/v1/ai/forecast_revenue \\
  -H 'Content-Type: application/json' \\
  -H 'X-Customer-Api-Id: 4d09ffe5-33d7-4a63-b4fd-fc1decf4fa8f' \\
  -H 'X-Secret: AfIqb2F9JNET_‚Ä¶HzHUa0w' \\
  -d '{"region":"EU","horizon":12,"include_promotions":true}'
```

### Under the Hood

1. Proxy checks your plan-to-queue mapping (`Business -> tasks-medium`)
2. Verifies if downstream path is allowed
3. Task saved in **Cosmos DB** with `status: "queued"`
4. One `UsageRecord` is debited
5. Job is enqueued to **Azure Service Bus**
6. Worker runs AI model ‚Üí writes `status: "completed"` in Cosmos DB

### Response (HTTP 202 - Queued)

```json
{
  "task_id": "c7d1b5e76c67485eab1c9a407f7e6a97",
  "queue": "tasks-medium",
  "status": "queued"
}
```

> üí° Tip: Everything you `POST` is stored exactly as given. You can send large, nested objects.

---

## 1.4 Check Task Status / Download Results

### 1.4.1 List Recent Jobs

```http
GET /api/v1/taskadmin/tasks?status_filter=completed&limit=20
```

Same authentication headers.

### 1.4.2 Fetch One Job

```http
GET /api/v1/taskadmin/tasks/{task_id}?part=response
```

#### cURL

```bash
curl -sS \
  'https://api-prod.abintel.app/api/v1/taskadmin/tasks/{task_id}?part=response' \
  -H 'X-Customer-Api-Id: 4d09ffe5-33d7-4a63-b4fd-fc1decf4fa8f' \
  -H 'X-Secret: AfIqb2F9JNET_‚Ä¶HzHUa0w'
```

#### Example ‚Äì Success

```json
{
  "auc": 0.912,
  "predictions": [ ... ],
  "interpretation": "Model XGBoost ‚Äì good separation."
}
```

#### Example ‚Äì Failure

```json
{
  "error": "HTTP 500 Server Error: ‚Ä¶",
  "status_code": 500
}
```

---

## 1.5 Live Queue & Worker Dashboards

| **Endpoint**                  | **Use-case**                                                        | **Example**                                       |
| ----------------------------- | ------------------------------------------------------------------- | ------------------------------------------------- |
| `GET /taskadmin/queue/stats`  | Summary ‚Äì queued / completed / failed counts per queue + oldest job | `GET /api/v1/taskadmin/queue/stats`               |
| `GET /taskadmin/queue/queued` | Paginated dump for custom dashboards                                | `GET /api/v1/taskadmin/queue/queued?queue=medium` |

> üß† Both endpoints query Cosmos DB ‚Äì no worker load.

---

## 1.6 Usage / Billing APIs

| Endpoint                       | Description                        |
| ------------------------------ | ---------------------------------- |
| `GET /taskadmin/usage/month`   | Current month call count & cost    |
| `GET /taskadmin/usage/history` | Historical usage and cost by month |

#### Example Response

```json
{
  "month": "2025-05",
  "calls": 842,
  "cost": 42.10
}
```

> üí∞ Costs are derived from `UsageRecord.cost`. You can define per-route pricing.

---

## 1.7 Typical Lifecycle

```mermaid
sequenceDiagram
    Customer ->> Proxy /ai/... : POST payload
    Proxy ->> Cosmos DB : Save task (status="queued")
    Proxy ->> Azure Service Bus : Enqueue task
    Worker ->> Azure Bus : Poll
    Worker ->> AI Backend : POST for processing
    Worker ->> Cosmos DB : Save (status="completed" + response)
    Customer ->> /taskadmin/tasks/{id}?part=response : Fetch result
```

---

## 1.8 Error Handling Cheatsheet

| **Status**  | **Meaning**            | **Next Step**                             |
| ----------- | ---------------------- | ----------------------------------------- |
| `queued`    | Awaiting a free worker | Check `/queue/stats` for backlog          |
| `completed` | Result ready           | Download it                               |
| `failed`    | Error or timeout       | Inspect `error` field; retry if transient |

---

## 1.9 FAQ

* **How long do results stay?** 30 days (default)
* **Can I cancel a job?** Not yet ‚Äî open a support ticket
* **Timeouts?** 60s hard timeout; chunk large jobs
* **Security?** TLS 1.2+ for data in transit; data encrypted at rest; API secrets stored as salted hashes

---

## 1.10 Getting Credentials

- Request a Customer API ID and Secret via the ABIntel console or support.
- Use separate credentials per environment (dev, staging, prod).
- Store secrets in a secure secret manager; rotate regularly.
- Recommended environment variables: `ABINTEL_API_ID`, `ABINTEL_SECRET`.

---

## 1.11 Quickstart ‚Äî Python

```python
import os, requests

BASE = "https://api-prod.abintel.app/api/v1"
HEADERS = {
    "Content-Type": "application/json",
    "X-Customer-Api-Id": os.getenv("ABINTEL_API_ID"),
    "X-Secret": os.getenv("ABINTEL_SECRET"),
}

# 1) Queue a task
payload = {"region": "EU", "horizon": 12, "include_promotions": True}
r = requests.post(f"{BASE}/ai/forecast_revenue", json=payload, headers=HEADERS, timeout=30)
r.raise_for_status()
task = r.json()
print("Queued:", task)

# 2) Fetch result (simple one-shot fetch; for polling, loop with backoff)
task_id = task["task_id"]
s = requests.get(f"{BASE}/taskadmin/tasks/{task_id}?part=response", headers=HEADERS, timeout=15)
s.raise_for_status()
print("Result:", s.json())
```

---

## 1.12 Quickstart ‚Äî Node.js (fetch)

```js
// Node 18+ with global fetch
const BASE = "https://api-prod.abintel.app/api/v1";
const HEADERS = {
  "Content-Type": "application/json",
  "X-Customer-Api-Id": process.env.ABINTEL_API_ID,
  "X-Secret": process.env.ABINTEL_SECRET,
};

(async () => {
  // 1) Queue a task
  const res = await fetch(`${BASE}/ai/forecast_revenue`, {
    method: "POST",
    headers: HEADERS,
    body: JSON.stringify({ region: "EU", horizon: 12, include_promotions: true }),
  });
  if (!res.ok) throw new Error(`Queue failed: ${res.status} ${await res.text()}`);
  const task = await res.json();
  console.log("Queued:", task);

  // 2) Fetch result (simple one-shot fetch; for polling, loop with backoff)
  const status = await fetch(`${BASE}/taskadmin/tasks/${task.task_id}?part=response`, { headers: HEADERS });
  if (!status.ok) throw new Error(`Fetch failed: ${status.status} ${await status.text()}`);
  console.log("Result:", await status.json());
})();
```

---

## 1.13 Rate Limits & Retries

- 429 Too Many Requests indicates throttling. Back off and retry.
- Use jittered exponential backoff (e.g., 0.5s ‚Üí 1s ‚Üí 2s ‚Üí 4s; add ¬±20% jitter).
- Respect `Retry-After` when present; cap total retry time/budget.
- Treat network errors and most 5xx as transient; avoid retrying 4xx except 408/409/429.
- For queued tasks, polling every 2‚Äì5s is typical; increase interval under load.

---

## 1.14 Payload Size & Chunking

- Keep request bodies compact; remove null/unused fields.
- For large inputs (e.g., logs, documents), upload to object storage and pass a signed URL or reference in the payload.
- Split very large batches into smaller jobs to avoid timeouts and ease retries.

---

## 1.15 Idempotency & De-duplication

- If you need at-least-once submission safety, include a deterministic `client_task_id` in your payload so your system can ignore duplicates on success.
- Avoid client-side blind retries without a correlation key; prefer controlled retries with correlation metadata.

#### Example body with a client correlation key

```json
{
  "client_task_id": "rev-fore-2025-05-store-42",
  "region": "EU",
  "horizon": 12,
  "include_promotions": true
}
```

---

## 1.16 Taskadmin Access Scope

- Task administration endpoints are intended for administrative usage only.
- Restrict credentials with least privilege; separate operational and admin keys.
- Access is limited to your tenant‚Äôs data. Contact support to enable or fine-tune admin access.

---

## 1.17 OpenAPI & Support

- An OpenAPI 3.0 specification is available on request. If your tenant exposes a docs URL, it is typically advertised in your onboarding email.
- For production support or limits (rate/payload/retention) specific to your plan, contact support.

---
