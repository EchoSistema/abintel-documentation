# 4.2.8 /api/v1/ai/dynamic_pricing_recommend
+> Nota: tradução gerada automaticamente a partir do inglês; revise antes de publicar.


## AI-Driven Price Optimisation in <150 ms\

## Objetivo

One call returns the profit- or revenue-maximising price for a SKU, using a micro-trained demand model that considers:

* Historical sell-through

* Competitor prices

* Current inventory

* Shopper context (channel/country)

## Typical lift:

+3–9% gross margin or +4–12% top-line revenue (validated in 14 retailers).

---

### Headers `X-Customer-Api-Id`, `X-Secret`

```yaml
POST  https://api-prod.abintel.ai/api/v1/ai/dynamic_pricing_recommend
Headers
  X-Customer-Api-Id: <uuid>
  X-Secret:          <secret>
  Content-Type:      application/json
```

---

### Business Value

| **Scenario**              | **How this endpoint helps**                           | **Impact**                 |
| ------------------------- | ----------------------------------------------------- | -------------------------- |
| Daily price suggestion    | Scheduled call uploads updated prices to POS / web    | +4–6% gross profit         |
| Flash sale tuning         | Frequent calls optimize discount velocity and margins | Sell aged stock 30% faster |
| Competitor price matching | Undercuts rivals only if margin stays healthy         | Hold share, protect margin |
| Marketplace auto-repricer | Trigger on every new bid                              | +15–25% Buy Box win rate   |

---

### Request Body – Schema & Field Descriptions

| **Field**                  | **Type / Range**           | **Required** | **Description**                              |
| -------------------------- | -------------------------- | ------------ | -------------------------------------------- |
| `product_id`               | `string`                   | ✅           | SKU to price                                |
| `cost_per_unit`            | `float ≥ 0`                | ✅           | Landed cost incl. logistics                 |
| `optimize_for`             | \`"profit"                 | "revenue"    | ✅                                          |
| `candidate_prices`         | `array<float>`             | ✅           | Price points to evaluate                    |
| `historical[]`             | `array<object> (≥10 rows)` | ✅           | Recent sales data to train the model        |
| `competitor_price_current` | `float`                    | optional     | Live rival price (defaults to last observed) |
| `inventory_level_current`  | `int`                      | optional     | Current stock level                          |
| `segment_current`          | `object`                   | optional     | Contextual info: channel, country, etc.      |

---

### Historical Row Fields

| **Field**          | **Type**   | **Required** | **Description**                               |
| ------------------ | ---------- | ------------ | --------------------------------------------- |
| `date`             | `ISO date` | ✅            | Day of sale                                  |
| `price`            | `float`    | ✅            | Price used that day                          |
| `units_sold`       | `int ≥ 0`  | ✅            | Quantity sold                                |
| `competitor_price` | `float`    | optional     | Rival price on same day                       |
| `inventory_level`  | `int ≥ 0`  | optional     | Inventory at start of day                     |
| `segment`          | `object`   | optional     | e.g., `{ "channel": "web", "country": "BR" }` |

---

### Sample Request

```json
{
  "product_id": "SKU-123",
  "cost_per_unit": 50.0,
  "optimize_for": "profit",
  "candidate_prices": [79.0, 89.0, 99.0, 109.0],
  "historical": [
    { "date": "2025-03-01", "price": 99.0, "units_sold": 38, "competitor_price": 95.0, "inventory_level": 180, "segment": { "channel": "web", "country": "BR" } },
    { "date": "2025-03-02", "price": 99.0, "units_sold": 41, "competitor_price": 96.0, "inventory_level": 170, "segment": { "channel": "web", "country": "BR" } },
    ...
    { "date": "2025-03-10", "price": 109.0, "units_sold": 25, "competitor_price": 103.0, "inventory_level": 200, "segment": { "channel": "store", "country": "BR" } }
  ],
  "competitor_price_current": 94.0,
  "inventory_level_current": 120,
  "segment_current": { "channel": "mobile", "country": "BR" }
}
```

---

### Engine Workflow (Simplified)

1. Clean & encode data (e.g., one-hot segment, log transform).

2. Train ElasticNet, XGBoost, Random Forest on 75% of history.

3. Extract demand elasticity.

4. Predict demand per price in candidate_prices.

5. Compute:

* revenue = price × expected_units

* profit = (price – cost) × expected_units

6. Select best_price based on objective (profit or revenue).

7. Apply guardrails (min margin, max discount).

8. Return prediction.

9. Log for drift monitoring.

---

### Resposta

```json
{
  "best_price": 79.0,
  "outcomes": [
    { "candidate_price": 79.0, "expected_units": 85.0, "expected_revenue": 6714.9, "expected_profit": 2464.96 },
    { "candidate_price": 89.0, "expected_units": 61.13, "expected_revenue": 5440.35, "expected_profit": 2383.97 },
    { "candidate_price": 99.0, "expected_units": 44.56, "expected_revenue": 4411.79, "expected_profit": 2183.61 },
    { "candidate_price": 109.0, "expected_units": 35.23, "expected_revenue": 3839.86, "expected_profit": 2078.46 }
  ],
  "model_info": {
    "algorithm": "XGBoost",
    "mape": 0.0,
    "train_rows": 10
  },
  "interpretation": "Setting the price at 79.00 maximises PROFIT: +3.4% versus the next-best option (89.00) given today’s competitor price (94.0) and inventory level (120 units)."
}
```

---

### Response Fields

| **Field**              | **Type** | **Description**                  | **Use Case**               |
| ---------------------- | -------- | -------------------------------- | -------------------------- |
| `best_price`           | `float`  | Optimal price                    | Push to web/POS            |
| `outcomes[]`           | `array`  | Simulated results per candidate  | Build price ladders        |
| ↳ `expected_units`     | `float`  | Forecasted demand                | Plan inventory or ops      |
| ↳ `expected_revenue`   | `float`  | Price × Units                    | —                          |
| ↳ `expected_profit`    | `float`  | (Price – Cost) × Units           | —                          |
| `model_info.algorithm` | `string` | Chosen ML model                  | ML audit                   |
| `model_info.mape`      | `float`  | Mean Absolute % Error (hold-out) | Trigger retrain if > 0.2   |
| `interpretation`       | `string` | Plain-English summary            | Show in pricing dashboards |

---

### Commercial Playbooks

| **Use-case**         | **Recipe**                                                             | **KPI Lift**             |
| -------------------- | ---------------------------------------------------------------------- | ------------------------ |
| Clear slow movers    | Use `[cost×1.05, cost×1.1…]`, optimize\_for: `"revenue"`               | Free DC space 25% faster |
| Flagship products    | Call every 2h if `MAPE < 0.10`; widen price range if `elasticity > -2` | Protect margin & share   |
| End-of-season sale   | Set `cost=0`; maximize revenue                                         | +8–12% clearance revenue |
| Channel segmentation | Call twice: `segment_current.channel = web` vs. `store`                | AOV +3%, Profit +4%      |

---

### Engineering & Ops Tips

* Candidate grid: Try 4–8 prices near current tag

* Psychology-aware: Include .90, .99 variants

* Lagging competitor: Use competitor_price_current explicitly

* Inventory spike: Narrow grid to preserve margin

* Batch nightly: Loop SKUs, push best prices to ERP

* A/B test: +10% pricing to 10% traffic to measure elasticity

---

### FAQ

| **Q**                                    | **A**                                                        |
| ---------------------------------------- | ------------------------------------------------------------ |
| What if `MAPE = 0.00`?                   | Likely only 1 hold-out row; add more historical data.        |
| Minimum distinct prices?                 | At least two – otherwise no curve fitting possible.          |
| Can I add features like weekday/weather? | Yes – include as columns in `historical[]`; auto-encoded.    |
| Currency format?                         | Use same currency throughout; endpoint is currency-agnostic. |
| How to set pricing guardrails?           | Use header: `X-Min-Margin-Pct: 0.25` (Enterprise only).      |

---

### Próximo Passo

Feed yesterday’s sales snapshot into this endpoint with 4–8 candidate prices.
Then push the `best_price` to your e-commerce, store POS or marketplace.
Measure margin lift in days – most clients break even on implementation in < 30 days.

---

